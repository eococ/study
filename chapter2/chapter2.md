# 데이터 타입

**1) 기본 타입** <br>
	- 정수 타입(byte, short, int, long) 
	- 실수 타입(float, double)
	- 논리 타입(boolean)
	- 문자 타입(char)


<table>
	<tr>
		<th>종류</th>
		<th>기본타입</th>
		<th>타입크기(byte)</th>
	</tr>
	<tr>
		<td rowspan="5">정수</td>
		<td>byte</td>
		<td>1byte</td>
	</tr>
	<tr>
		<td>char</td>
		<td>2byte</td>
	</tr>
	<tr>
		<td>short</td>
		<td>2byte</td>
	</tr>
	<tr>
		<td>int</td>
		<td>4byte</td>
	</tr>
	<tr>
		<td>long</td>
		<td>8byte</td>
	</tr>
	<tr>
		<td rowspan="2">실수</td>
		<td>float</td>
		<td>4byte</td>
	</tr>
	<tr>
		<td>double</td>
		<td>8byte</td>
	</tr>
	<tr>
		<td>논리</td>
		<td>boolean</td>
		<td>1byte</td>
	</tr>		
</table>
	
**2) 참조 타입** 
> 객체의 번지를 참조하는 타입으로 기본 타입과의 차이는 '저장되는 값이 무엇인가'에 있다. 
기본 타입으로 선언된 변수는 실제 값을 변수에 저장하지만 참조 타입은 배열, 열거, 클래스, 인터페이스를 이용해서 선언된 변수로 메모리에 번지를 값으로 갖게 된다. 즉 __번지를 통해 객체를 참조__한다는 뜻으로 참조타입이라고 부른다. <br>
또한 기본 데이터 타입은 데이터가 생성되는 위치가 스택 영역이지만 참조 데이터 타입은 힙 영역에 생성된다. <br>
```
	ex) int num = 10; <br>
	double price = 10.5; <br>
	String name = "지민"; <br>
	String hobby = "영화"; <br>
	<br>
```	

|스택 영역  		| 힙 영역 		  |
| ---- 				| ----	  		  |
| num = 10;			| 15번지 : "지민" |		
| price = 10.5  	| 200번지 : "영화"|
| name = 15번지		|				  |
| hobby = 200번지 	|				  |
	
<br>
	- 배열 <br>
	- 열거 타입 <br>
	- 클래스 <br>
	- 인터페이스 <br>


<br> <br> <br> <br>		



# 메모리 사용 영역 `java`

- JVM (자바 가상 머신)이 사용하는 메모리 영역(Runtime Data Area)

- java.exe로 java 프로그램을 실행하게 되면 운영체제로부터 JVM(Java Vitural Machine)은 메모리를 할당받고 이를 몇가지 영역으로 세분화하여 	  	  관리하게 된다. JVM은 메모리를 __메소드 영역__, __힙 영역__, **스레드 단위**로 구분하여 관리하게 된다.
<br> <br> <br>


__메소드 영역__ <br>
- 코드에서 사용되는 클래스(.class) 들을 로더로 읽어서 클래스 별로 런타임 상수풀(상수풀 : 문자상수, 타입, 필드, 객체참조가 저장됨), 필드 	  	  데이터, 메소드 데이터, 메소드 코드, 생성자 코드 등으로 분류해서 저장하게 된다. 일반적으로 static으로 선언된 값들 역시 이 과정에서 메소드 영역에 저장된다.
<br> <br>
	  
이 곳에 생성된 데이터는 JVM이 실행되는 순간에 자동으로 생성된다. 프로그래밍 과정에서 아직 수행되지 않은 static 영역의 데이터에 접근할 수 있는 이유도 static으로 선언된 값이 JVM이 실행되는 순간에 메모리에 올라가기 때문이다. <br>
여기에 저장된 값들은 모든 쓰레드가 공유하는 값이다.
	  
<br> <br> <br>
__힙 영역__
- 동적인 메소드 영역
- new 키워드로 생성된 객체(Object)와 배열(Array)이 생성되는 영역, 생성된 객체는 스택 영역의 변수나 다른 객체 필드에서 참조한다.
- 참조하는 변수나 필드가 없다면, 의미 없는 객체(쓰레기)로 분류되어 가비지 컬렉터가 자동으로 제거한다. (객체를 직접 제거하는 방법 제공X)
- 런타임시 할당된다.
	
<br> <br> <br>
__스택 영역__
- 각 스레드마다 하나씩 존재, 스레드가 시작할 때 할당된다.
- 추가적으로 스레드를 생성하지 않았다면, main 스레드만 존재한다.
- 메소드를 호출할 때마다 프레임을 추가(push)하고, 메소드 종료 시 해당 프레임 제거
- 프레임 안에는 로컬 변수 스택이 있다. 변수가 최초로 초기화될 때 로컬 변수 스택에 생성된다. (변수는 선언된 블록 안에서만 스택에 존재, 블록을 벗어나면 스택에서 제거된다.)
- 컴파일 타임 시 할당된다.
<br> <br> <br>

&nbsp;&nbsp; 

```html
<참고>
스레드 : 한 프로그램의 작업 단위를 의미한다.
컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정(systenx Error, 파일 참조 오류, 타입 체크 오류 등)
런타임 : 컴파일 타임 이후 프로그램이 실행되는 때(0 나누기 오류, null 참조 오류, 메모리 부족 오류)

Q. 멀티스레드 시 공유되는 메모리 영역은?
```
	

	
	
# wrapper class `java`
- 자바 API 클래스 중 하나이다.
- 자바의 기본 타입 8개(byte, short, char, int, long, float, double, boolean)에 해당하는 데이터를 객체로 표현해야 하는 경우 
  **기본 자료타입을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스(wrapper class)**라고 한다. 
  래퍼 클래스로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없다. 만약 값을 변경하고 싶다면 새로운 포장 객체를 만들어야 한다.
- 래퍼 클래스는 java.lang 패키지에 포함되어 있다.
- 모든 래퍼 클래스의 부모는 Object이고 내부적으로 숫자를 다루는 래퍼클래스의 부모 클래스는 Number 클래스이다. 모든 래퍼 클래스는 최종 		클래스로 정의된다.
	
ex) 메소드의 파라미터로 객체 타입만이 요구될 경우
	- 기본 타입의 데이터를 그대로 사용할 수도 있지만(AutoBoxing을 통해 가능해진다.) 
	기본 타입의 데이터를 먼저 객체로 변환 후 작업을 수행해야 한다.
	<br><br>
	** 박싱 : 기본 타입의 값을 포장 객체로 만드는 과정 <br>
	** 언박싱 : 포장객체에서 기본타입의 값을 얻어내는 과정 <br>
	** 자동박싱 & 자동언박싱 : 기본타입 값을 직접 박싱, 언박싱하지 않아도 자동적으로 박싱과 언박싱이 일어나는 경우가 있다. <br>
		자동 박싱의 포장 클래스 타입에 기본값이 대입될 경우에 발생한다. 예를 들어 int타입의 값을 Integer 클래스 변수에 대입하면 자동 박싱이 일어나
		힙 영역에 Integer 객체가 생성된다.
		
- 래퍼 클래스의 종류

|	기본타입	|	래퍼클래스	|
| 	------		|	------		|
|	byte		|	Byte		|
|	char		|	Character	|
|	int			| 	Integer		|
|	float		|	Float		|
|	double		|	Double		|
|	boolean		|	Boolean		|
|	long		|	Long		|
|	short		|	Short		|

<br>

		


# 변수

**변수란? : 하나의 값을 저장할 수 있는 메모리 공간**
<br>

- **변수 선언 방법** <br>
	( 변수타입 ) ( 변수이름 ) ex) int age;
<br>
	
- __지역변수 / 전역변수__ <br>
	- 자바의 변수는 선언 위치에 따라 크게 전역변수와 지역 변수로 나뉜다. <br>
	- **전역변수**는 함수 바깥에 선언하여 클래스 전체에서 사용가능한 변수이다. <br>
	  **지역변수**는 함수 속에 선언하여 해당 함수 속에서만 사용가능한 변수이다. <br>	
	- 전역변수의 경우 그 내에서도 (1)인스턴스 변수와 (2)클래스 변수로 나뉜다. 
	<br><br>

- **인스턴스 변수 / 클래스 변수**

		
|	변수 종류		| 	선언위치 			|	생성시기(메모리 할당 시기)		|
|	------			|	------				|		------						|
|	클래스 변수 	| 	클래스 영역 		|	클래스가 메모리에 올라갔을 때	|
|	인스턴스 변수	|	클래스 영역 		|	인스턴스(객체)가 생성될 때		|
|	지역 변수 		|	클래스 이외 영역 	|	변수 선언문이 수행되었을 때		|


**(1) 인스턴스 변수** <br>
>클래스 영역에 선언되고, 인스턴스(객체)를 생성할 때 만들어진다. <br>
>그렇기 때문에 인스턴스의 변수 값을 가져오기 위해선 일단 인스턴스를 생성해줘야 한다.<br>
>인스턴스는 독립적인 저장공간을 가지기 때문에 서로 다른 값을 가질 수 있음. 인스턴스마다 고유한 상태를 유지해야 하는 속성의 경우,
>인스턴스 변수로 선언한다.<br>
	
**(2) 클래스 변수**<br>
>클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static만 붙여주면 된다. 클래스 변수는 모든 인스턴스가 공통된 저장공간을 공유한다. <br>
>한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 경우 클래스 변수로 선언한다. <br>
>클래스 변수는 인스턴스 변수와는 달리 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다.


__인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만,__ __클래스 변수는 모든 인스턴스가 하나의__
__저장 공간을 공유하므로, 항상 공통된 값을 갖는다.__
		

		
<br><br><br><br>	


	
		
# 스코프
__스코프란__ 변수에 접근하거나 접근할 수 있는 유효 범위/영역으로 블록은 왼쪽 중괄호 `{`로 시작하고 오른쪽 중괄호 `}`로 끝난다.<br>
<br>


**1.javascript에서의 스코프** <br>
&nbsp;&nbsp; (1) 전역 스코프 : 코드 어디에서든지 참조할 수 있다. <br>
&nbsp;&nbsp; (2) 지역 스코프 : 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다. <br>
	
**2. java에서의 스코프** <br>
&nbsp;&nbsp; (1) 클래스의 속성으로 선언된 변수 사용 범위는 클래스 전체이다. <br>
&nbsp;&nbsp; (2) 메소드의 매개변수로 선언된 변수의 사용 범위는 해당 메소드 블럭 내이다. <br>



<br><br><br><br>
	

	
# 호이스팅 `javascript`
__호이스팅__ var을 통해 정의된 변수의 선언문을 유효 범위의 최상단으로 끌어올리는 행위 를 말한다.
	'선언과 할당의 분리'라고 생각하면 기억하기 좋다.
	
**(1) 호이스팅**	

```javascript
	//개발자가 작성한 코드 
	if(true){
		var name="jimin";
	}
			console.log(name);
			
	//호이스팅으로 변환된 코드 
	var name; //선언
	if(true){
		name="jimin";  //할당
	}
```

**(2) 함수 호이스팅** : 함수의 선언 역시 호이스팅의 대상이다. 때문에 스코프 내에서 어떤 위치에서 함수 선언을 하든지 호출할 수 있다.

```javascript
	//개발자가 작성한 코드 
	sayName();
	
	function sayname(){
		console.log('jimin');
	}
			
	//호이스팅으로 변환된 코드 
	function sayName(){
		console.log('jimin');
	}
	
	sayName();
```

함수 선언 역시 최상단으로 끌어올려지기 때문에 sayName()을 먼저 호출하고 함수 정의를 해도 정상적으로 동작하게 된다.
<br><br><br><br>



# 변수 네이밍
- 대소문자가 구분된다.
- 길이에 제한이 없다.
- 변수명에 예약어가 올 수 없다.
- 숫자로 시작할 수 없다.
- 특수문자는 _(언더바) 와 $만 가능하다.
- 상수는 모두 대문자로 작성한다.
- 여러단어로 이루어진 경우 단어의 첫글자를 대문자로 한다. ex)variableExample
- 한글로도 작성가능하나, 영어를 원칙으로 한다.
<br>



<br><br><br><br>




# 프로토타입(prototype) 기반 프로그래밍이란?
> 객체의 원형인 프로토 타입을 이용하여 새로운 객체를 만들어내는 프로그래밍 기법이다. 이렇게 만들어진 객체 역시 자기 자신의 프로토타입을 갖는다. 이 새로운 객체의 원형을 이용하면 또 다른 새로운 객체를 만들어 낼 수도 있으며 이런 구조로 객체를 확장하는 방식을 프로토타입 기반 프로그래밍이라고 한다.


** 자바스크립트에서 사용되는 프로토 타입 **

- Array.prototype.indexOf
- Array.prototype.slice
- Array.prototype.splice
- Array.prototype.join
- Array.prototype.push
- Array.prototype.pop
- Array.prototype.unshift
- Array.prototype.shift
- Array.prototype.fill

<br>

- Array.prototype.forEach
- Array.prototype.find
- Array.prototype.filter
- Array.prototype.map
- Array.prototype.some
- Array.prototype.every
- Array.prototype.reduce


# 얕은 복사 / 깊은 복사

**1. 얕은 복사 : 참조(주소)값의 복사를 나타낸다.**
	
```javascript
	
const obj = {value : 1}
const newObj : obj;
	
newObj.value = 2;
console.log(obj.value); // 2
console.log(obj === newObj); // true
```

obj 객체를 새로운 newObj 객체에 할당하였으며 이를 **참조할당**이라고 부른다. 복사 후 newObj 객체의 <br>
value 값을 변경하면 기존의 obj.value 값도 변경된다. 두 객체를 비교해도 true로 나온다. <br>
이렇게 자바스크립트의 참조 타입은 얕은 복사가 된다고 볼 수 있다. 이는 데이터가 그대로 생성되는 것이 아닌 <br>
해당 데이터의 참조 값(메모리 주소)를 전달하여 결국 한 데이터를 공유하는 것이다.


**2. 깊은 복사 : 깊은 복사는 값 자체의 복사를 나타낸다.**

```javascript
	let a = 1;
	let b = a;
	
	b = 2;
	
	console.log(a); //1
	console.log(b); //2
	console.log(a === b); //false
```
	

   

